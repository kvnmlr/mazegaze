\documentclass{sigchi}

% Use this section to set the ACM copyright statement (e.g. for
% preprints).  Consult the conference website for the camera-ready
% copyright statement.

% Copyright
% \CopyrightYear{2016}
%\setcopyright{acmcopyright}
% \setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}
% DOI
% \doi{}
% ISBN
% \isbn{}
%Conference
% \conferenceinfo{}{}
%Price
% \acmPrice{}

% Load basic packages
\usepackage{balance}       % to better equalize the last page
\usepackage{graphics}      % for EPS, load graphicx instead 
\usepackage[T1]{fontenc}   % for umlauts and other diaeresis
\usepackage{txfonts}
\usepackage{mathptmx}
\usepackage[pdflang={en-US},pdftex]{hyperref}
\usepackage{color}
\usepackage{booktabs}
\usepackage{textcomp}


% Some optional stuff you might like/need.
\usepackage{microtype}        % Improved Tracking and Kerning
% \usepackage[all]{hypcap}    % Fixes bug in hyperref caption linking
\usepackage{ccicons}          % Cite your images correctly!
% \usepackage[utf8]{inputenc} % for a UTF8 editor only

% If you want to use todo notes, marginpars etc. during creation of
% your draft document, you have to enable the "chi_draft" option for
% the document class. To do this, change the very first line to:
% "\documentclass[chi_draft]{sigchi}". You can then place todo notes
% by using the "\todo{...}"  command. Make sure to disable the draft
% option again before submitting your final document.
\usepackage{todonotes}

% Paper metadata (use plain text, for PDF inclusion and later
% re-using, if desired).  Use \emtpyauthor when submitting for review
% so you remain anonymous.
\def\plaintitle{Maze Gaze - A Gaze-Based Multiplayer Game}
\def\plainauthor{Kevin MÃ¼ller, Marco Siweris, Lena}
\def\emptyauthor{}
\def\plainkeywords{eye-tracking; gaze-based interaction; multi-user interaction; human computer interaction;}
\def\plaingeneralterms{Documentation, Standardization}

% llt: Define a global style for URLs, rather that the default one
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{
    \def\UrlFont{\sf}
  }{
    \def\UrlFont{\small\bf\ttfamily}
  }}
\makeatother
\urlstyle{leo}

% To make various LaTeX processors do the right thing with page size.
\def\pprw{8.5in}
\def\pprh{11in}
\special{papersize=\pprw,\pprh}
\setlength{\paperwidth}{\pprw}
\setlength{\paperheight}{\pprh}
\setlength{\pdfpagewidth}{\pprw}
\setlength{\pdfpageheight}{\pprh}

% Make sure hyperref comes last of your loaded packages, to give it a
% fighting chance of not being over-written, since its job is to
% redefine many LaTeX commands.
\definecolor{linkColor}{RGB}{6,125,233}
\hypersetup{%
  pdftitle={\plaintitle},
% Use \plainauthor for final version.
%  pdfauthor={\plainauthor},
  pdfauthor={\emptyauthor},
  pdfkeywords={\plainkeywords},
%  pdfdisplaydoctitle=true, % For Accessibility
%  bookmarksnumbered,
%  pdfstartview={FitH},
%  colorlinks,
%  citecolor=black,
%  filecolor=black,
%  linkcolor=black,
%  urlcolor=linkColor,
%  breaklinks=true,
%  hypertexnames=false
}

% create a shortcut to typeset table headings
% \newcommand\tabhead[1]{\small\textbf{#1}}

% End of preamble. Here it comes the document.
\begin{document}

\title{\plaintitle}

\numberofauthors{3}
\author{%
  \alignauthor{Kevin M{\"u}ller\\
    \affaddr{Saarland University}\\
    \affaddr{Saarbr{\"u}cken, Germany}\\
    \email{s9kvmuel@stud.uni-saarland.de}}\\
  \alignauthor{Marco Siweris\\
    \affaddr{Saarland University}\\
    \affaddr{Saarbr{\"u}cken, Germany}\\
    \email{s8masiwe@stud.uni-saarland.de}}\\
  \alignauthor{Lena Hornberger\\
    \affaddr{Saarland University}\\
    \affaddr{Saarbr{\"u}cken, Germany}\\
    \email{s8lehorn@stud.uni-saarland.de}}\\
}

\maketitle

\begin{abstract}
This paper is the result of the Seminar "Multi-User Gaze-Based Interaction" at the Saarland University. We designed and implemented an interactive application which uses gaze input. The result of this development is a gaze based multiplayer game called "Maze Gaze" in the category "Multi-User Content Adaption". In this paper we present our project idea, the requirements we made, some design and software decisions and show that a game with gaze input can make a lot of fun despite working with a eyetracker can cause a lot of issues.
\end{abstract}

% \keywords{\plainkeywords}

\section{Introduction}
1/4 page intro (Kevin)
\subsection{Motivation}
Gaze can be a very intuitive and fast way of interacting with a system. However, there are still many unsolved problems related to areas such as tracking accuracy, calibration methods or unintended interactions. Because of that, currently eye-tracking is still very uncommon for end users although applications of it are countless. Researchers are working hard on solving those issues and making eye-tracking more usable in different areas of life, both for personal and professional use.\\
There is another important fact to consider: People who are partially or fully paralized have a very limited set of possibilities to interact with their environment. Because it is a hand-free interaction, gaze can be a very benefitial for people with physical impairments, giving them many possibilities to interact with other people and perform tasks that otherwise would be very hard or even impossible.

\subsection{Goal}
Our goal in this project is to develop a game that can be played only using the eyes. Evenmore, we want this game to be fun to play and fair against conventional input methods like mouse or keyboard. This way, everyone, including physically impaired people, can have an immersive and competitive gaming experience against other players. By doing so, we hope to gain valuable insights and make a contribution in this field of research.

\subsection{Outline}
This paper consists of three main parts. The first one will lay out the foundation for the project. After examining related work from several perspectives, we will define requirements and make concrete design decisions based on the ideas we got from related papers. In the second part, we will look at the actual implementation of the prototype and explain both hardware, software and how we made it play together. The final part closes the software design cycle by evaluating the game from a performance and user-experience perspective. Based on the results and the lessons we learned along the way, we will draw conclusions and propose future work.

\section{Related Work}
\subsection{Gaze Input Performance}
\cite{san2009evaluation} 1/2 page (Kevin)
\subsection{Mouse Against Gaze Input}
\cite{dorr2009gaze} 1/2 page (Kevin)
\subsection{Immersive Game Controll Using Gaze}
The paper "Gaze-Controlled Gaming: Immersive and Difficult but not Cognitively Overloading" was published in 2014 from Kreytz et al. in Warsaw, Poland and present at the UbiCom in September 2014 in Seatlle, USA \cite{krejtz2014gaze}.\\
The paper is about controlling games through eye-movements.\\
In the experiment the participants should guide a character trough a maze with their eye movements. It was design within-subjects and had two fixed factors. The first was the game-control type which can be differ in 3 types: gaze-controlled with cues, gaze-controlled without cues and keyboard-controlled. The second factor was the maze complexity(easy and hard). Each participants played all three versions of the game two times, once with the easy and once with the hard maze.\\
The results important for our project: the completion time was faster with cues, but there were more saccades and there were more saccades with the complex maze, but the participants were gazing on the paths of the maze about 60\% of the time.\\
This resulted the main question: moving the character or scanning paths? For our project this means, that we are switching between two modes: gaze-controlled gaming an visual field scanning. This means we only move the character when the gaze is within a given radius. Moreover we do the game without cues that show possible directions, because this reduce the game experience. 
\subsection{Pursuit Calibration}
The paper "Pursuit Calibration: Making Gaze Calibration Less Tedious and More Flexible" was published in 2013 from Pfeuffer et al. and present at the UIST in October 2013 in St. Andrews, United Kingdom \cite{pfeuffer2013pursuit}.\\
As we know, every application which works with gaze input needs a user calibration before you can interact with it. But a "normal" calibration maybe is difficult and tedious. It requires five or more calibration points. In this paper they present another method to calibrate: "Pursuit Calibration" at which the users are following moving targets to calibrate.\\
In the experiment they test how the calibration should be: They test different speeds of the moving target and the time the target moves. First the target moves with a constant speed and second with a accelerating moving target which slows down at the corner of the screen and accelerates at the straight side of the screen. The results were: The target does not have the travel across the entire screen, because the final accuracy is already reached around 66\% of its whole path and durations that lasts longer than 10 seconds are better.\\
This resulted how the calibration should be: it should introduce users to the application and be very intuitive (e.g in a stargazing application, following shooting stars). The duration of the calibration should be between 10 to 20 seconds and the size of the target should be, in our case, the width of the path, because the size of the target has an impact on the accuracy of the calibration.\\
In our project the pursuit calibration was a may have we did not implemented.

---\\
TOTAL: 1.5 Pages

\section{Requirements and Design}
\subsection{Gaze Interaction Design Decisions}
1/2 page (Marco) (Farben, Content Adaption (private public shared areas), radius)
\subsection{Agile Development Approach}
The main advantage of taking an iterative approach in the development of such projects is, that one can get working prototypes really quickly and adapt the goals and requirements based on the evaluation of those prototypes. Also, by doing vertical prototypes, i.e. ones that only implement a single unit of functionality, technical limitations can be uncovered early in the development.\\
Initially, in our small team of three, we defined high-level milestones with deadlines that would eventually lead to the completion of the project within the given time frame. Each week, we met to discuss and assign smaller action items called ''issues'' to each team member using GitLab. Our initial focus was on developing two prototypes that would ensure our idea was possible. We implemented a horizontal prototype with a limited set of features, very basic graphics and only mouse and keyboard controlls. By testing this prototype with some users, we could quickly find out that our game is indeed fun to play and the competitive nature of the game does work.\\
Because this has not been done before and there was no reference implementation online, we did a vertical prototype covering the eye-tracking functionality to ensure we could receive the gaze data from multiple eye trackers. After a while, this worked and we could focus on putting both prototypes together into a working gaze-controlled game and increasing its technical and visual fidelity.
\subsection{Formal Requirements}
	Must-Haves
	\begin{itemize}
		\item You could play the game on a conventional Laptop display or TV set
		\item It could play 1-4 players at a time 
		\item \textbf{Player can enter a running game???} 
		\item The match field is a maze consisting of walls and paths 
		\item Maze is random generated. The Maze does not change in playtime
		\item Each Player starts in one corner of the Maze
		\item At the beginning of the game is the hole maze dark
		\item The play figure of a player is a coloured light cone
		\item Each player has a different colour
		\item Light cone follows the gaze of the player
		\item Light cone tries to follow the gaze in a constant speed and tries to minimize the distance to the gaze
		\item If the distance of the gaze an the light cone is too big, the gaze can no longer be control the light cone.
		\item 	If the light cone can not minimize the distance to the gaze because of walls, he stops
		\item 	A small part around the light cone is lit
		\item The paths on which the light cone had previously been left also remain bright, but gradually darken
		\item 	illuminated area is only for the player visible how reached the are
		\item If a player's gaze moves near a path discovered by another opponent and not by himself, it is completely darkened 
		\item 	The light cone of the player is always lit
		\item 	Lightened areas a player himself has discovered will not be darkened for this player, even if they were discovered by another player
		\item At the beginning of a round, a target is placed at a random position in the maze
		\item It gave different good power ups (enlightenment, show tart, endurance)
	\end{itemize}
	May-Haves
	\begin{itemize}
		\item Player can choose different levels at the beginning of a round, thereby increasing the size of the maze
		\item New players could join a game, without pausing 
		\item More different bad power ups (dim, slowing, darkness)
		\item If a player does not look at the field for more than 10 seconds, he leaves the game and his light cone disappears from the field
		
	\end{itemize}
---\\
TOTAL: 1.25 Pages

\section{Implementation}
1/4 page intro
\subsection{Hardware}
1/4 page (Kevin)
\subsection{Software}
2 pages
\subsubsection{Menu}
At the beginning of the game you can choose between many game configurations. You have the option to start the game, to finish the application, to get some help information (e.g. link to GitLab) and to call settings, where you can connect to new clients, disconnect connected clients and calibrate clients. On starting the game you can set the game configurations. You can choose the number of players, the number of rounds you want to play and the difficulty of the game (simple, medium or hard) which affects the size of the labyrinth and the paths. If the game lasts longer than one round the next round starts automatically after a short break. The game also supports in-game interruptions with a break button. In this interruption mode you can continue the game and also go back to the main menu.
\subsubsection{Maze Generator} 
The Maze a generated with a depth-first-search algorithm. First we generate a $n*m$ large matrix and in every step we have a wall from $x_{0}$ to $x_{n}$ and from $y_{0}$ to $y_{m}$. In the next step we generate a datatype Cell with four walls per Cell (north, south, east, west). Now we will chose a random start cell, and destroy a random wall which has not yet been destroyed from this cell and progress with death-first-search in every cell of the matrix. You can solve this problem with a running time of $\mathcal{O}(n^2)$.
\subsubsection{Power-Ups} We distinguish the power-ups in good and bad power ups. The good power-ups are enlightenment, endurance and show target. Enlightenment is a light explosion, if a player collect this target, a big range of $nMazeSize/7 * mMazeSize/7$ will lit. Endurance is a power-up which bring about light path is lit for a longer time. The power-up show target trigger a light flash on the target for one seconds. The bad power-ups are dim, slowing and darkness. Dim is the opposite of endurance, so the the light path is lit for a shorter time, but only of the opponents. The power ups slowing produce that the opponents getting slower and the slower speed is fix, and the player can not get his old faster speed. Darkness extinguishes the light of the opponents. 
\subsubsection{Smart Player Controls} Kevin
\subsubsection{Game Fairness} Kevin
\subsubsection{Pupil Integration} Kevin
\subsubsection{Calibration} Kevin
\subsubsection{Game Lobbys} Kevin
\subsubsection{Graphical Interface} 

Marco
---\\
TOTAL: 2.5 pages


\section{Evaluation}
\subsection{Performance}
1/4 page (Lena)
\subsection{User-Experience}
1/4 page (Lena)\\
---\\
TOTAL: 0.5 page

\section{Conclusion}
\subsection{R{\'e}sume}
1/4 page (Lena)
\subsection{Lessons Learned}
1/4 page (Kevin)
\subsection{Future Work}
In general, there are many possibilities to extend the game MazeGaze. In stead of control the menu by mouse we could implement a gaze bases control menu. So for example the user have to look in different areas to choose different options in the menu. For instance the person has to look in the upper left corner to choose the game option to play in a small maze. Another approach would be, the user has to control a light cone in certain corner to choose something. This is also a good way of training before the the game starts.\\ 
We also could create a collaborative team mode so that two players are in a team and other to players are in a opponent team. The teams have to play against each other. That means, if a player of the one team collect a bad power-up it just will be triggered on the members of the other team and not for the player of the own team.\\ 
Another idea would be to change the maze in play time. Like the game "\textit{Labyrinth}" from Ravensburger in 1986. A algorithm destroy walls and build up other walls, but still it is a fair maze, so every player can reach each point of the maze. This ensures that the users can not only rely on their memory, but also a luck factor plays a role.\\
Another point is the continuation and improvement of the calibration. We could implement a In-application-calibration, so that means if we press the calibration button, the calibration will start on the desktop where the game is running and not on the desktop where the eye tracker is connected. This ensures a better and more precise calibration. Also we could implement a  in-application pursuit calibration to get a more precise calibration and better results and a low frustration of the user.\\ 
To reduce the frustration of the user, we could improve the gaze precision. The gaze precision is currently good enough to have a good gaming experience without major frustrations but not perfect yet. The improvement is possible by adding algorithms to the actual gaze position calculated to the desired position. \\
Last but not least we could implement a queue to start waiting players in a fair, right sequence. If, for example, 5 people want to play, we have a problem, because the game is design for four users. So the fifth user have wait and getting in a virtual queue, when one of the four players leave to game, the waiting person will spawn in the next round. If we have two or more waiting users, they are arranged in a queue, with the principle, first come first serve.
\\
TOTAL: 1.0 page

\section{TOTAL: 8 pages}

\balance{}


% REFERENCES FORMAT
% References must be the same font size as other body text.
\bibliographystyle{SIGCHI-Reference-Format}
\bibliography{sample}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
